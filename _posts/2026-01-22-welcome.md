---
layout: post
title: git rebase 충돌 메세지 읽기
date: 2026-01-23 11:30:00 +0900
categories:
  - Daily
modified: 2026-01-24
---
# Git Rebase 동작 원리: Reset과 Cherry-pick의 과정

깃 히스토리를 단장하기 위해 git rebase를 사용하는 일이 많습니다.
그러다 보면 자주 발생하는 상황이 바로 충돌입니다.
## 시나리오 가정
```
    (origin/dev)
          |
    A --- B --- C --- D
           \
            E --- F
            |     |
         (666fdee) (feat: refactor)
                  |
               (feat, 현재 브랜치)
```
* **dev (Target Base)**: `A -> B` 이후 `C`, `D`가 추가된 상태 (업데이트된 메인 브랜치)
* **feat (Current Work)**: `B`에서 갈라져 나와 `E`, `F`를 작업한 상태
* **충돌 커밋**: `E` (사용자의 커밋 해시: `666fdee`)
* **명령어**: `git rebase dev` 실행

이 때 충돌이 나는 경우 다음과 같은 형태의 메세지를 만나게 되는데, 
```
<<<<<<< HEAD
    summary="Send test message (no auth, streaming only)",
    description="""인증 없이 테스트 메시지를 전송하고 AI 응답을 스트리밍으로 받습니다.
=======
    response_model=TestMessageResponse,
    summary="Send test message (no auth)",
    description="""인증 없이 테스트 메시지를 전송하고 AI 응답을 JSON으로 받습니다.

>>>>>>> 666fdee (feat: Change streaming -> response)
```
여기서 HEAD는 어디를 말하는거고(나는 분명 feat: refactor에 있었는데), 666fdee는 무슨 커밋 인가?? 하는게 늘 헷갈립니다.
햇갈리는 일이 없도록 이해해 봅십니다.

## 핵심 개념
> **"Rebase는 HEAD를 대상 브랜치로 Reset한 뒤, 기존 커밋들을 하나씩 Cherry-pick 하는 과정이다."**

rebase를 위해 Git은 내부적으로 **"베이스 이동(Reset) -> 커밋 재적용(Cherry-pick)"**의 절차를 밟습니다.

## 단계별 설명

### Step 1: Rebase 시작 전 (Before)
두 브랜치가 `B` 시점에서 갈라져 있는 일반적인 상태입니다.
```
    (origin/dev)
          |
    A --- B --- C --- D
           \
            E --- F
            |     |
         (666fdee) (feat: ...)
                  |
               (feat, 현재 브랜치)
```

### Step 2: 임시 저장 및 Reset (베이스 이동)
Git은 `feat`의 커밋들(`E`, `F`)을 임시 저장소(Patch)에 보관하고, `feat` 브랜치의 포인터를 `dev`의 최신 커밋인 `D`로 **강제 이동(Reset)** 시킵니다.
```
                      (HEAD가 여기로 강제 이동됨)
                           ↓
    A --- B --- C --- D   (feat)
           \
            (E, F는 잠시 공중에 뜸 / 임시 저장됨)
```

### Step 3: 첫 번째 Cherry-pick (충돌 발생)
임시 저장된 첫 번째 커밋 `E (666fdee)`를 가져와서 `D` 뒤에 붙이려고 시도합니다. 이때 **Cherry-pick**이 수행됩니다.

```
                           (dev)
                             |
    A --- B --- C --- D ... [E'] <-- E를 여기에 붙이는 중...
                             |
                           (충돌 발생!)
```

* **상황**: `HEAD`인 `D`의 코드와, 가져오려는 `E(666fdee)`의 코드가 같은 부분을 수정하고 있어 Git이 멈춤.(정확히는 공통 조상을 바탕으로 3way merge를 시도 함)
* **마커 분석**:
    * `<<<<<<< HEAD`: `D`의 내용 (기존 베이스)
    * `>>>>>>> 666fdee`: `E`의 내용 (내 수정사항)
* **해결**: 충돌 해결 후 `git rebase --continue` 입력 시 `E'` 생성 완료.

### Step 4: 나머지 Cherry-pick 및 완료 (After)
`E'`가 완성되면 다음 커밋인 `F`를 가져와 붙입니다(`F'`). 모든 커밋이 이동되면 역사가 **한 줄(Linear)**로 정리됩니다.

```
                           (dev)
                             |
    A --- B --- C --- D --- E' --- F'
                                    |
                                 (feat)
```
##  핵심 요약
1.  **커밋 해시 변경**: 그림에서 `E`가 `E'`가 된 것처럼, 코드는 같지만 베이스가 `B`에서 `D`로 바뀌었기 때문에 **완전히 새로운 커밋 해시**가 발급됩니다.
2.  **충돌의 원인**: `E`를 만들 때는 `B`를 보고 작성했지만, Rebase를 통해 `D` 위에 얹혀야 하므로 그 사이(`C`, `D`)의 변경 사항과 충돌이 발생하는 것입니다.
3. HEAD의 의미는 내가 rebase 명령을 입력했을 때의 HEAD가 아닌 하나씩 cherry-pick을 하면서 변경되는 위치를 의미하는 것입니다. 따라서 어디에서 충돌이 나느냐에 따라 HEAD가 의미하는 위치는 다릅니다.